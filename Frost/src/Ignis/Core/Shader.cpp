#include "Shader.h"

#include <fstream>

namespace ignis
{
	static GLuint s_activeProgram = 0;

	static std::string readFile(const std::string& path)
	{
		std::ifstream ifs(path);

		if (ifs) return std::string(std::istreambuf_iterator<char>(ifs.rdbuf()), std::istreambuf_iterator<char>());

		return std::string();
	}

	static char* read_file(const char* path)
	{
		char* data = NULL;
		size_t size = 0;

		FILE* file;

		if ((file = fopen(path, "rb")) == NULL)
		{
			_ignisErrorCallback(ignisErrorLevel::Warn, "[SHADER] Failed to open file : %s", path);
			return NULL;
		}

		// find file size
		fseek(file, 0, SEEK_END);
		size = ftell(file);
		rewind(file);

		data = (char*)malloc(size + 1);
		if (!data)
		{
			_ignisErrorCallback(ignisErrorLevel::Warn, "[SHADER] Failed to allocate memory");
			fclose(file);
			return NULL;
		}

		memset(data, 0, size + 1); // +1 guarantees trailing \0

		if (fread(data, size, 1, file) != 1)
		{
			free(data);
			fclose(file);
			return NULL;
		}

		return data;
	}

	Shader::Shader(const char* vert, const char* frag)
	{
		char* vert_src = read_file(vert);
		char* frag_src = read_file(frag);

		GLenum types[] = { GL_VERTEX_SHADER, GL_FRAGMENT_SHADER };
		const char* sources[] = { vert_src, frag_src };

		m_program = CreateShaderProgram(types, sources, 2);

		free(vert_src);
		free(frag_src);
	}

	Shader::Shader(const char* vert, const char* geom, const char* frag)
	{
		char* vert_src = read_file(vert);
		char* geom_src = read_file(geom);
		char* frag_src = read_file(frag);

		GLenum types[] = { GL_VERTEX_SHADER, GL_GEOMETRY_SHADER, GL_FRAGMENT_SHADER };
		const char* sources[] = { vert_src, geom_src, frag_src };

		m_program = CreateShaderProgram(types, sources, 2);

		free(vert_src);
		free(geom_src);
		free(frag_src);
	}

	Shader::~Shader()
	{
		glDeleteProgram(m_program);
	}

	void Shader::Use()
	{
		// check if program handle refer to an object generated by OpenGL
		IGNIS_ASSERT(glIsProgram(m_program));

		if (s_activeProgram != m_program)
		{
			glUseProgram(m_program);
			s_activeProgram = m_program;
		}
	}

	void Shader::SetUniform1i(const char* name, int value) const
	{
		int location = GetUniformLocation(name);

		if (location < 0)
			_ignisErrorCallback(ignisErrorLevel::Warn, "[SHADER] Uniform %s not found", name);
		else
			SetUniform1i(location, value);
	}

	void Shader::SetUniform1f(const char* name, float value) const
	{
		int location = GetUniformLocation(name);

		if (location < 0)
			_ignisErrorCallback(ignisErrorLevel::Warn, "[SHADER] Uniform %s not found", name);
		else
			SetUniform1f(location, value);
	}

	void Shader::SetUniform2f(const char* name, const float* values) const
	{
		int location = GetUniformLocation(name);

		if (location < 0)
			_ignisErrorCallback(ignisErrorLevel::Warn, "[SHADER] Uniform %s not found", name);
		else
			SetUniform2f(location, values);
	}

	void Shader::SetUniform3f(const char* name, const float* values) const
	{
		int location = GetUniformLocation(name);

		if (location < 0)
			_ignisErrorCallback(ignisErrorLevel::Warn, "[SHADER] Uniform %s not found", name);
		else
			SetUniform3f(location, values);
	}

	void Shader::SetUniform4f(const char* name, const float* values) const
	{
		int location = GetUniformLocation(name);

		if (location < 0)
			_ignisErrorCallback(ignisErrorLevel::Warn, "[SHADER] Uniform %s not found", name);
		else
			SetUniform4f(location, values);
	}

	void Shader::SetUniformMat2(const char* name, const float* values) const
	{
		int location = GetUniformLocation(name);

		if (location < 0)
			_ignisErrorCallback(ignisErrorLevel::Warn, "[SHADER] Uniform %s not found", name);
		else
			SetUniformMat2(location, values);
	}

	void Shader::SetUniformMat3(const char* name, const float* values) const
	{
		int location = GetUniformLocation(name);

		if (location < 0)
			_ignisErrorCallback(ignisErrorLevel::Warn, "[SHADER] Uniform %s not found", name);
		else
			SetUniformMat3(location, values);
	}

	void Shader::SetUniformMat4(const char* name, const float* values) const
	{
		int location = GetUniformLocation(name);

		if (location < 0)
			_ignisErrorCallback(ignisErrorLevel::Warn, "[SHADER] Uniform %s not found", name);
		else
			SetUniformMat4(location, values);
	}

	int Shader::GetUniformLocation(const char* name) const
	{
		return glGetUniformLocation(m_program, name);
	}

	void Shader::SetUniform1i(int location, int value) const
	{
		glUniform1i(location, value);
	}

	void Shader::SetUniform1f(int location, float value) const
	{
		glUniform1f(location, value);
	}

	void Shader::SetUniform2f(int location, const float* values) const
	{
		glUniform2fv(location, 1, values);
	}

	void Shader::SetUniform3f(int location, const float* values) const
	{
		glUniform3fv(location, 1, values);
	}

	void Shader::SetUniform4f(int location, const float* values) const
	{
		glUniform4fv(location, 1, values);
	}

	void Shader::SetUniformMat2(int location, const float* values) const
	{
		glUniformMatrix2fv(location, 1, GL_FALSE, values);
	}

	void Shader::SetUniformMat3(int location, const float* values) const
	{
		glUniformMatrix3fv(location, 1, GL_FALSE, values);
	}

	void Shader::SetUniformMat4(int location, const float* values) const
	{
		glUniformMatrix4fv(location, 1, GL_FALSE, values);
	}

	// Shader utils
	GLuint CreateShaderProgram(GLenum* types, const char** sources, size_t count)
	{
		GLuint program = glCreateProgram();

		GLuint attached_shader[6];
		GLuint shader_count = 0;

		for (size_t i = 0; i < count; i++)
		{
			GLuint shader = CompileShader(types[i], sources[i]);

			if (shader == 0)
			{
				glDeleteProgram(program);
				return 0;
			}

			glAttachShader(program, shader);
			attached_shader[shader_count] = shader;
			shader_count++;
		}

		glLinkProgram(program);

		for (size_t i = 0; i < shader_count; i++)
		{
			glDeleteShader(attached_shader[i]);
			glDetachShader(program, attached_shader[i]);
		}

		GLint result = GL_FALSE;
		glGetProgramiv(program, GL_LINK_STATUS, &result);
		if (result == GL_FALSE)
		{
			_ignisErrorCallback(ignisErrorLevel::Error, "[SHADER] Linking Error");
			PrintProgramLog(program);
			glDeleteProgram(program);
			return 0;
		}

		glValidateProgram(program);

		result = GL_FALSE;
		glGetProgramiv(program, GL_VALIDATE_STATUS, &result);
		if (result == GL_FALSE)
		{
			_ignisErrorCallback(ignisErrorLevel::Error, "[SHADER] Validating Error");
			PrintProgramLog(program);
			glDeleteProgram(program);

			return 0;
		}

		return program;
	}

	GLuint CompileShader(GLenum type, const char* source)
	{
		if (source[0] == '\0')
		{
			_ignisErrorCallback(ignisErrorLevel::Error, "[SHADER] Shader source is missing for %s", GetShaderType(type));
			return 0;
		}

		GLuint shader = glCreateShader(type);

		glShaderSource(shader, 1, &source, nullptr);
		glCompileShader(shader);

		GLint result = GL_FALSE;
		glGetShaderiv(shader, GL_COMPILE_STATUS, &result);
		if (result == GL_FALSE)
		{
			_ignisErrorCallback(ignisErrorLevel::Error, "[SHADER] Compiling Error (%s)", GetShaderType(type));
			PrintShaderLog(shader);
			glDeleteShader(shader);

			return 0;
		}

		return shader;
	}

	void PrintShaderLog(GLuint shader)
	{
		if (!glIsShader(shader))
		{
			_ignisErrorCallback(ignisErrorLevel::Error, "[SHADER] Failed to log: Object is not a shader");
			return;
		}

		GLint log_length = 0;
		glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &log_length);
		char* log_buffer = (char*)malloc(log_length);
		glGetShaderInfoLog(shader, log_length, &log_length, log_buffer);

		_ignisErrorCallback(ignisErrorLevel::Error, "[SHADER] %.*s", log_length, log_buffer);

		free(log_buffer);
	}

	void PrintProgramLog(GLuint program)
	{
		if (!glIsProgram(program))
		{
			_ignisErrorCallback(ignisErrorLevel::Error, "[SHADER] Failed to log: Object is not a program");
			return;
		}

		GLint log_length = 0;
		glGetShaderiv(program, GL_INFO_LOG_LENGTH, &log_length);
		char* log_buffer = (char*)malloc(log_length);
		glGetShaderInfoLog(program, log_length, &log_length, log_buffer);

		_ignisErrorCallback(ignisErrorLevel::Error, "[SHADER] %.*s", log_length, log_buffer);

		free(log_buffer);
	}

	const char* GetShaderType(GLenum type)
	{
		switch (type)
		{
		case GL_COMPUTE_SHADER:
			return "GL_COMPUTE_SHADER";
		case GL_VERTEX_SHADER:
			return "GL_VERTEX_SHADER";
		case GL_TESS_CONTROL_SHADER:
			return "GL_TESS_CONTROL_SHADER";
		case GL_TESS_EVALUATION_SHADER:
			return "GL_TESS_EVALUATION_SHADER";
		case GL_GEOMETRY_SHADER:
			return "GL_GEOMETRY_SHADER";
		case GL_FRAGMENT_SHADER:
			return "GL_FRAGMENT_SHADER";
		}

		return "INVALID_SHADER_TYPE";
	}
}