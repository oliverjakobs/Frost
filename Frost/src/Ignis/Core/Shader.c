#include "Shader.h"

#include "../Ignis.h"

static GLuint _ignisActiveProgram = 0;

int ignisShadervf(ignis_shader* shader, const char* vert, const char* frag)
{
	char* vert_src = ignisReadFile(vert, NULL);
	if (!vert_src)
	{
		_ignisErrorCallback(IGNIS_ERROR, "[SHADER] Failed to read file: %s", vert);
		return 0;
	}

	char* frag_src = ignisReadFile(frag, NULL);
	if (!frag_src)
	{
		_ignisErrorCallback(IGNIS_ERROR, "[SHADER] Failed to read file: %s", frag);
		return 0;
	}

	if (!(vert_src && frag_src))
		return 0;

	GLenum types[] = { GL_VERTEX_SHADER, GL_FRAGMENT_SHADER };
	const char* sources[] = { vert_src, frag_src };

	GLuint program = ignisCreateShaderProgram(types, sources, 2);

	if (shader)
		shader->program = program;

	free(vert_src);
	free(frag_src);

	return program;
}

int ignisShadervgf(ignis_shader* shader, const char* vert, const char* geom, const char* frag)
{
	char* vert_src = ignisReadFile(vert, NULL);
	if (!vert_src)
	{
		_ignisErrorCallback(IGNIS_ERROR, "[SHADER] Failed to read file: %s", vert);
		return 0;
	}

	char* geom_src = ignisReadFile(geom, NULL);
	if (!geom_src)
	{
		_ignisErrorCallback(IGNIS_ERROR, "[SHADER] Failed to read file: %s", geom);
		return 0;
	}

	char* frag_src = ignisReadFile(frag, NULL);
	if (!frag_src)
	{
		_ignisErrorCallback(IGNIS_ERROR, "[SHADER] Failed to read file: %s", frag);
		return 0;
	}

	GLenum types[] = { GL_VERTEX_SHADER, GL_GEOMETRY_SHADER, GL_FRAGMENT_SHADER };
	const char* sources[] = { vert_src, geom_src, frag_src };

	GLuint program = ignisCreateShaderProgram(types, sources, 2);

	if (shader)
		shader->program = program;

	free(vert_src);
	free(frag_src);

	return program;
}

void ignisDeleteShader(ignis_shader* shader)
{
	glDeleteProgram(shader->program);
}

void ignisUseShader(ignis_shader* shader)
{
	// check if program handle refer to an object generated by OpenGL
	IGNIS_ASSERT(glIsProgram(shader->program));

	if (_ignisActiveProgram != shader->program)
	{
		glUseProgram(shader->program);
		_ignisActiveProgram = shader->program;
	}
}

GLint ignisGetUniformLocation(const ignis_shader* shader, const char* name)
{
	GLint location = glGetUniformLocation(shader->program, name);

	if (location < 0)
		_ignisErrorCallback(IGNIS_WARN, "[SHADER] Uniform %s not found", name);

	return location;
}

void ignisSetUniform1i(const ignis_shader* shader, const char* name, int value)
{
	GLint location = ignisGetUniformLocation(shader, name);

	if (location >= 0)
		ignisSetUniform1il(location, value);
}

void ignisSetUniform1f(const ignis_shader* shader, const char* name, float value)
{
	GLint location = ignisGetUniformLocation(shader, name);

	if (location >= 0)
		ignisSetUniform1fl(location, value);
}

void ignisSetUniform2f(const ignis_shader* shader, const char* name, const float* values)
{
	GLint location = ignisGetUniformLocation(shader, name);

	if (location >= 0)
		ignisSetUniform2fl(location, values);
}

void ignisSetUniform3f(const ignis_shader* shader, const char* name, const float* values)
{
	GLint location = ignisGetUniformLocation(shader, name);

	if (location >= 0)
		ignisSetUniform3fl(location, values);
}

void ignisSetUniform4f(const ignis_shader* shader, const char* name, const float* values)
{
	GLint location = ignisGetUniformLocation(shader, name);

	if (location >= 0)
		ignisSetUniform4fl(location, values);
}

void ignisSetUniformMat2(const ignis_shader* shader, const char* name, const float* values)
{
	GLint location = ignisGetUniformLocation(shader, name);

	if (location >= 0)
		ignisSetUniformMat2l(location, values);
}

void ignisSetUniformMat3(const ignis_shader* shader, const char* name, const float* values)
{
	GLint location = ignisGetUniformLocation(shader, name);

	if (location >= 0)
		ignisSetUniformMat3l(location, values);
}

void ignisSetUniformMat4(const ignis_shader* shader, const char* name, const float* values)
{
	GLint location = ignisGetUniformLocation(shader, name);

	if (location >= 0)
		ignisSetUniformMat4l(location, values);
}

void ignisSetUniform1il(GLint location, int value)
{
	glUniform1i(location, value);
}

void ignisSetUniform1fl(GLint location, float value)
{
	glUniform1f(location, value);
}

void ignisSetUniform2fl(GLint location, const float* values)
{
	glUniform2fv(location, 1, values);
}

void ignisSetUniform3fl(GLint location, const float* values)
{
	glUniform3fv(location, 1, values);
}

void ignisSetUniform4fl(GLint location, const float* values)
{
	glUniform4fv(location, 1, values);
}

void ignisSetUniformMat2l(GLint location, const float* values)
{
	glUniformMatrix2fv(location, 1, GL_FALSE, values);
}

void ignisSetUniformMat3l(GLint location, const float* values)
{
	glUniformMatrix3fv(location, 1, GL_FALSE, values);
}

void ignisSetUniformMat4l(GLint location, const float* values)
{
	glUniformMatrix4fv(location, 1, GL_FALSE, values);
}

GLuint ignisCreateShaderProgram(GLenum* types, const char** sources, size_t count)
{
	GLuint program = glCreateProgram();

	GLuint attached_shader[6];
	GLuint shader_count = 0;

	for (size_t i = 0; i < count; i++)
	{
		GLuint shader = ignisCompileShader(types[i], sources[i]);

		if (shader == 0)
		{
			glDeleteProgram(program);
			return 0;
		}

		glAttachShader(program, shader);
		attached_shader[shader_count] = shader;
		shader_count++;
	}

	glLinkProgram(program);

	for (size_t i = 0; i < shader_count; i++)
	{
		glDeleteShader(attached_shader[i]);
		glDetachShader(program, attached_shader[i]);
	}

	GLint result = GL_FALSE;
	glGetProgramiv(program, GL_LINK_STATUS, &result);
	if (result == GL_FALSE)
	{
		_ignisErrorCallback(IGNIS_ERROR, "[SHADER] Linking Error");
		ignisPrintProgramLog(program);
		glDeleteProgram(program);
		return 0;
	}

	glValidateProgram(program);

	result = GL_FALSE;
	glGetProgramiv(program, GL_VALIDATE_STATUS, &result);
	if (result == GL_FALSE)
	{
		_ignisErrorCallback(IGNIS_ERROR, "[SHADER] Validating Error");
		ignisPrintProgramLog(program);
		glDeleteProgram(program);

		return 0;
	}

	return program;
}

GLuint ignisCompileShader(GLenum type, const char* source)
{
	if (source[0] == '\0')
	{
		_ignisErrorCallback(IGNIS_ERROR, "[SHADER] Shader source is missing for %s", ignisGetShaderType(type));
		return 0;
	}

	GLuint shader = glCreateShader(type);

	glShaderSource(shader, 1, &source, NULL);
	glCompileShader(shader);

	GLint result = GL_FALSE;
	glGetShaderiv(shader, GL_COMPILE_STATUS, &result);
	if (result == GL_FALSE)
	{
		_ignisErrorCallback(IGNIS_ERROR, "[SHADER] Compiling Error (%s)", ignisGetShaderType(type));
		ignisPrintShaderLog(shader);
		glDeleteShader(shader);

		return 0;
	}

	return shader;
}

void ignisPrintShaderLog(GLuint shader)
{
	if (!glIsShader(shader))
	{
		_ignisErrorCallback(IGNIS_ERROR, "[SHADER] Failed to log: Object is not a shader");
		return;
	}

	GLint log_length = 0;
	glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &log_length);
	char* log_buffer = (char*)malloc(log_length);
	glGetShaderInfoLog(shader, log_length, &log_length, log_buffer);

	_ignisErrorCallback(IGNIS_ERROR, "[SHADER] %.*s", log_length, log_buffer);

	free(log_buffer);
}

void ignisPrintProgramLog(GLuint program)
{
	if (!glIsProgram(program))
	{
		_ignisErrorCallback(IGNIS_ERROR, "[SHADER] Failed to log: Object is not a program");
		return;
	}

	GLint log_length = 0;
	glGetShaderiv(program, GL_INFO_LOG_LENGTH, &log_length);
	char* log_buffer = (char*)malloc(log_length);
	glGetShaderInfoLog(program, log_length, &log_length, log_buffer);

	_ignisErrorCallback(IGNIS_ERROR, "[SHADER] %.*s", log_length, log_buffer);

	free(log_buffer);
}

const char* ignisGetShaderType(GLenum type)
{
	switch (type)
	{
	case GL_COMPUTE_SHADER:
		return "GL_COMPUTE_SHADER";
	case GL_VERTEX_SHADER:
		return "GL_VERTEX_SHADER";
	case GL_TESS_CONTROL_SHADER:
		return "GL_TESS_CONTROL_SHADER";
	case GL_TESS_EVALUATION_SHADER:
		return "GL_TESS_EVALUATION_SHADER";
	case GL_GEOMETRY_SHADER:
		return "GL_GEOMETRY_SHADER";
	case GL_FRAGMENT_SHADER:
		return "GL_FRAGMENT_SHADER";
	}

	return "INVALID_SHADER_TYPE";
}